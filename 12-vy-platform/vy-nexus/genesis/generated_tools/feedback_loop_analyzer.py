#!/usr/bin/env python3
"""
FEEDBACK LOOP ANALYZER
Auto-generated by Recursive Tool Genesis

PURPOSE: Track and visualize feedback cycles across domains
PATTERN: FEEDBACK
DESCRIPTION: Identifies recursive patterns and measures loop strength
GENERATED: 2025-12-18 12:51:46
"""

import os
import json
import logging
from datetime import datetime
from typing import Dict, Any, List

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Paths
HOME = os.path.expanduser("~")
NEXUS_DIR = os.path.join(HOME, "vy-nexus")
MOIE_LOOP = os.path.join(HOME, "moie-mac-loop")
OUTPUT_DIR = os.path.join(NEXUS_DIR, "feedback_loop_analyzer_output")


class FeedbackLoopAnalyzer:
    """
    Identifies recursive patterns and measures loop strength
    
    This tool was auto-generated because the pattern 'FEEDBACK'
    appeared frequently with high confidence in synthesis results.
    """
    
    def __init__(self):
        """Initialize the feedback_loop_analyzer"""
        try:
            os.makedirs(OUTPUT_DIR, exist_ok=True)
            logger.info("âœ¨ FeedbackLoopAnalyzer initialized")
        except OSError as e:
            logger.error(f"Initialization failed: {e}")
            raise
    
    def analyze_feedback_patterns(self) -> Dict[str, Any]:
        """Analyze FEEDBACK patterns from MoIE history"""
        try:
            history_path = os.path.join(MOIE_LOOP, "moie_history.jsonl")
            
            if not os.path.exists(history_path):
                logger.warning("MoIE history not found")
                return {}
            
            patterns = []
            
            with open(history_path, 'r') as f:
                for line in f:
                    try:
                        entry = json.loads(line.strip())
                        
                        # Look for feedback keyword in content
                        content = str(entry.get('inversion', '')) + str(entry.get('content', ''))
                        
                        if 'feedback' in content.lower():
                            patterns.append({
                                'timestamp': entry.get('timestamp'),
                                'domain': entry.get('domain'),
                                'vdr': entry.get('vdr', 0),
                                'content': content[:200]
                            })
                    except json.JSONDecodeError:
                        continue
            
            logger.info(f"Found {len(patterns)} FEEDBACK patterns")
            
            return {
                'pattern': 'FEEDBACK',
                'total_occurrences': len(patterns),
                'patterns': patterns,
                'timestamp': datetime.now().isoformat()
            }
            
        except (OSError, IOError) as e:
            logger.error(f"Pattern analysis failed: {e}")
            return {}
    
    def generate_insights(self, analysis: Dict[str, Any]) -> List[str]:
        """Generate insights from FEEDBACK analysis"""
        try:
            insights = []
            
            if analysis.get('total_occurrences', 0) > 0:
                insights.append(f"{analysis['total_occurrences']} instances of FEEDBACK detected")
                
                # Domain distribution
                domains = [p['domain'] for p in analysis.get('patterns', []) if 'domain' in p]
                unique_domains = len(set(domains))
                insights.append(f"FEEDBACK appears across {unique_domains} domains")
                
                # VDR analysis
                vdrs = [p['vdr'] for p in analysis.get('patterns', []) if 'vdr' in p and p['vdr'] > 0]
                if vdrs:
                    avg_vdr = sum(vdrs) / len(vdrs)
                    insights.append(f"Average VDR for FEEDBACK: {avg_vdr:.2f}")
            
            return insights
            
        except (ValueError, TypeError, KeyError) as e:
            logger.error(f"Insight generation failed: {e}")
            return []
