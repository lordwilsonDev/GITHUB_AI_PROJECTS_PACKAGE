#!/usr/bin/env python3
"""
CONSTRAINT MAPPER
Auto-generated by Recursive Tool Genesis

PURPOSE: Map constraint networks and find optimal paths
PATTERN: CONSTRAINT
DESCRIPTION: Discovers which constraints enable vs restrict flow
GENERATED: 2025-12-18 12:51:46
"""

import os
import json
import logging
from datetime import datetime
from typing import Dict, Any, List

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Paths
HOME = os.path.expanduser("~")
NEXUS_DIR = os.path.join(HOME, "vy-nexus")
MOIE_LOOP = os.path.join(HOME, "moie-mac-loop")
OUTPUT_DIR = os.path.join(NEXUS_DIR, "constraint_mapper_output")


class ConstraintMapper:
    """
    Discovers which constraints enable vs restrict flow
    
    This tool was auto-generated because the pattern 'CONSTRAINT'
    appeared frequently with high confidence in synthesis results.
    """
    
    def __init__(self):
        """Initialize the constraint_mapper"""
        try:
            os.makedirs(OUTPUT_DIR, exist_ok=True)
            logger.info("âœ¨ ConstraintMapper initialized")
        except OSError as e:
            logger.error(f"Initialization failed: {e}")
            raise
    
    def analyze_constraint_patterns(self) -> Dict[str, Any]:
        """Analyze CONSTRAINT patterns from MoIE history"""
        try:
            history_path = os.path.join(MOIE_LOOP, "moie_history.jsonl")
            
            if not os.path.exists(history_path):
                logger.warning("MoIE history not found")
                return {}
            
            patterns = []
            
            with open(history_path, 'r') as f:
                for line in f:
                    try:
                        entry = json.loads(line.strip())
                        
                        # Look for constraint keyword in content
                        content = str(entry.get('inversion', '')) + str(entry.get('content', ''))
                        
                        if 'constraint' in content.lower():
                            patterns.append({
                                'timestamp': entry.get('timestamp'),
                                'domain': entry.get('domain'),
                                'vdr': entry.get('vdr', 0),
                                'content': content[:200]
                            })
                    except json.JSONDecodeError:
                        continue
            
            logger.info(f"Found {len(patterns)} CONSTRAINT patterns")
            
            return {
                'pattern': 'CONSTRAINT',
                'total_occurrences': len(patterns),
                'patterns': patterns,
                'timestamp': datetime.now().isoformat()
            }
            
        except (OSError, IOError) as e:
            logger.error(f"Pattern analysis failed: {e}")
            return {}
    
    def generate_insights(self, analysis: Dict[str, Any]) -> List[str]:
        """Generate insights from CONSTRAINT analysis"""
        try:
            insights = []
            
            if analysis.get('total_occurrences', 0) > 0:
                insights.append(f"{analysis['total_occurrences']} instances of CONSTRAINT detected")
                
                # Domain distribution
                domains = [p['domain'] for p in analysis.get('patterns', []) if 'domain' in p]
                unique_domains = len(set(domains))
                insights.append(f"CONSTRAINT appears across {unique_domains} domains")
                
                # VDR analysis
                vdrs = [p['vdr'] for p in analysis.get('patterns', []) if 'vdr' in p and p['vdr'] > 0]
                if vdrs:
                    avg_vdr = sum(vdrs) / len(vdrs)
                    insights.append(f"Average VDR for CONSTRAINT: {avg_vdr:.2f}")
            
            return insights
            
        except (ValueError, TypeError, KeyError) as e:
            logger.error(f"Insight generation failed: {e}")
            return []
