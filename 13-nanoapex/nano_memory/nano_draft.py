#!/usr/bin/env python3
import json
import sys
from pathlib import Path
from datetime import datetime
import uuid

NANO_MEMORY_DIR = Path.home() / "nano_memory"
INDEX_PATH = NANO_MEMORY_DIR / "index.jsonl"


def now_iso():
    return datetime.utcnow().isoformat() + "Z"


def load_index():
    entries = []
    if not INDEX_PATH.exists():
        print(f"[!] Index not found at {INDEX_PATH}")
        return entries
    with INDEX_PATH.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                entry = json.loads(line)
                # Only show real snippet entries
                if entry.get("kind") == "snippet":
                    entries.append(entry)
            except json.JSONDecodeError:
                continue
    return entries


def print_entry_list(entries):
    print("\n=== @nanoapex Snippet Index ===\n")
    for i, e in enumerate(entries):
        fn = e.get("function") or "<?function?>"
        src = e.get("source_path") or "<?source?>"
        created = e.get("created_at") or "<?time?>"
        print(f"[{i}] {fn}  | {src}  | {created}")
    print("")


def load_nano_file(rel_path: str):
    path = NANO_MEMORY_DIR / rel_path
    if not path.exists():
        print(f"[!] .nano file not found: {path}")
        return None
    raw = path.read_text(encoding="utf-8", errors="ignore")
    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        # wrap raw text
        return {
            "type": "raw_nano",
            "body": raw,
        }


def draft_proposed_change(snippet_text: str) -> str:
    """
    Placeholder for MoIE / local LLM.
    Right now we just scaffold a prompt-like space.
    Later you can replace this with a real model call.
    """
    header = (
        "# DRAFT: Proposed improvement generated by NanoApex pipeline.\n"
        "# TODO: Replace this text with MoIE / local model output.\n\n"
    )
    context = "# Original snippet for reference:\n"
    fenced = "```python\n" + snippet_text.strip() + "\n```\n"
    return header + context + fenced


def main():
    entries = load_index()
    if not entries:
        print("[!] No entries found in index.")
        return

    # Choose index
    if len(sys.argv) > 1:
        choice_arg = sys.argv[1]
    else:
        print_entry_list(entries)
        choice_arg = input("Select index to draft for (or 'q' to quit): ").strip()

    if choice_arg.lower() == "q":
        return

    if not choice_arg.isdigit():
        print("[!] Please pass a numeric index or 'q'.")
        return

    idx = int(choice_arg)
    if idx < 0 or idx >= len(entries):
        print("[!] Index out of range.")
        return

    entry = entries[idx]
    nano_rel = entry.get("nano_file")
    if not nano_rel:
        print("[!] Entry missing 'nano_file' field.")
        return

    payload = load_nano_file(nano_rel)
    if payload is None:
        return

    # Try to find snippet text
    snippet_text = (
        payload.get("snippet")
        or payload.get("body")
        or payload.get("code")
        or payload.get("text")
        or ""
    )

    if not snippet_text:
        print(f"[!] Could not find snippet text in .nano payload: {nano_rel}")
        print("    This looks like a draft or non-snippet .nano; only snippet-type .nano are valid sources.")
        return

    draft_text = draft_proposed_change(snippet_text)

    draft_id = str(uuid.uuid4())
    draft_filename = f"{draft_id}.nano"
    draft_path = NANO_MEMORY_DIR / draft_filename

    draft_obj = {
        "type": "improvement_draft",
        "source_chunk_id": entry.get("chunk_id"),
        "source_nano_file": nano_rel,
        "source_path": entry.get("source_path"),
        "function": entry.get("function"),
        "original_snippet": snippet_text,
        "proposed_change": draft_text,
        "status": "DRAFT",
        "created_at": now_iso(),
    }

    draft_path.write_text(
        json.dumps(draft_obj, indent=2, ensure_ascii=False),
        encoding="utf-8",
    )

    print("\n[âœ“] Draft created:")
    print(f"    {draft_path}")
    print("    type=improvement_draft status=DRAFT")

    # OPTIONAL: append to index.jsonl as its own entry
    with INDEX_PATH.open("a", encoding="utf-8") as f:
        f.write(
            json.dumps(
                {
                    "kind": "draft",
                    "nano_file": draft_filename,
                    "source_chunk_id": entry.get("chunk_id"),
                    "source_path": entry.get("source_path"),
                    "function": entry.get("function"),
                    "created_at": now_iso(),
                    "status": "DRAFT",
                }
            )
            + "\n"
        )
    print("[+] Indexed draft in index.jsonl as kind='draft'.")


if __name__ == "__main__":
    main()
