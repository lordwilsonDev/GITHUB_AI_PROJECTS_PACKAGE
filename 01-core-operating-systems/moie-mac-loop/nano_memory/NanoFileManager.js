// NanoFileManager.js - Core Nano Memory Organ
// Handles all file operations for the Nano Memory system

const fs = require('fs');
const path = require('path');

class NanoFileManager {
    constructor(baseDir = './nano_memory') {
        this.baseDir = baseDir;
        this.indexPath = path.join(baseDir, 'index.json');
        this.ensureDirectoryExists();
    }

    ensureDirectoryExists() {
        if (!fs.existsSync(this.baseDir)) {
            fs.mkdirSync(this.baseDir, { recursive: true });
        }
    }

    // Save a NanoRecord to both Markdown file and index
    async saveRecord(nanoRecord) {
        try {
            // Generate filename from timestamp and domain
            const timestamp = nanoRecord.timestamp.replace(/[:.]/g, '-');
            const domain = nanoRecord.domain.toLowerCase().replace(/\s+/g, '-');
            const filename = `${timestamp}_${domain}.md`;
            const filePath = path.join(this.baseDir, filename);

            // Create Markdown content
            const markdownContent = this.generateMarkdown(nanoRecord);
            
            // Write Markdown file
            fs.writeFileSync(filePath, markdownContent, 'utf8');

            // Update index
            await this.updateIndex(nanoRecord, filename);

            console.log(`✅ NanoRecord saved: ${filename}`);
            return { success: true, filename, path: filePath };
        } catch (error) {
            console.error('❌ Error saving NanoRecord:', error);
            return { success: false, error: error.message };
        }
    }

    // Generate Markdown content from NanoRecord
    generateMarkdown(record) {
        const { timestamp, domain, axiom, inversion, metrics, loveVector, tags, mode, wilsonGlitch } = record;
        
        return `# ${domain} Inversion

**Timestamp:** ${timestamp}
**Mode:** ${mode}
**Tags:** ${tags.join(', ')}

## Original Axiom
${axiom}

## Inversion
${inversion}

## Metrics
- **VDR (Violation Depth Rating):** ${metrics.vdr}/10
- **Semantic Coherence:** ${metrics.sem}
- **Complexity:** ${metrics.complexity}/10

## Love Vector
- **Care:** ${loveVector.care}
- **Growth:** ${loveVector.growth}
- **Truth:** ${loveVector.truth}
- **Beauty:** ${loveVector.beauty}

${wilsonGlitch ? '## Wilson Glitch
⚠️ Anomalous inversion detected
' : ''}

---
*Generated by MOTIA via Nano Memory Organ*
`;
    }

    // Update the master index.json
    async updateIndex(nanoRecord, filename) {
        let index = [];
        
        // Load existing index if it exists
        if (fs.existsSync(this.indexPath)) {
            const indexData = fs.readFileSync(this.indexPath, 'utf8');
            index = JSON.parse(indexData);
        }

        // Add new record to index
        const indexEntry = {
            id: index.length + 1,
            timestamp: nanoRecord.timestamp,
            domain: nanoRecord.domain,
            axiom: nanoRecord.axiom.substring(0, 100) + '...',
            vdr: nanoRecord.metrics.vdr,
            sem: nanoRecord.metrics.sem,
            complexity: nanoRecord.metrics.complexity,
            mode: nanoRecord.mode,
            tags: nanoRecord.tags,
            filename: filename,
            wilsonGlitch: nanoRecord.wilsonGlitch || false
        };

        index.push(indexEntry);

        // Write updated index
        fs.writeFileSync(this.indexPath, JSON.stringify(index, null, 2), 'utf8');
    }

    // VY Interface: Query methods
    getIndex() {
        if (!fs.existsSync(this.indexPath)) return [];
        const indexData = fs.readFileSync(this.indexPath, 'utf8');
        return JSON.parse(indexData);
    }

    // Get records by domain
    getByDomain(domain) {
        const index = this.getIndex();
        return index.filter(record => record.domain.toLowerCase() === domain.toLowerCase());
    }

    // Get high VDR records (Breakthrough Index)
    getBreakthroughs(minVdr = 7) {
        const index = this.getIndex();
        return index.filter(record => record.vdr >= minVdr)
                   .sort((a, b) => b.vdr - a.vdr);
    }

    // Get decision records
    getDecisions() {
        const index = this.getIndex();
        return index.filter(record => record.tags.includes('decision'));
    }

    // Get Wilson glitches
    getWilsonGlitches() {
        const index = this.getIndex();
        return index.filter(record => record.wilsonGlitch === true);
    }

    // Domain analysis for VY curriculum
    getDomainAnalysis() {
        const index = this.getIndex();
        const domains = {};
        
        index.forEach(record => {
            if (!domains[record.domain]) {
                domains[record.domain] = {
                    count: 0,
                    totalVdr: 0,
                    avgVdr: 0,
                    modes: {}
                };
            }
            
            domains[record.domain].count++;
            domains[record.domain].totalVdr += record.vdr;
            domains[record.domain].avgVdr = domains[record.domain].totalVdr / domains[record.domain].count;
            
            if (!domains[record.domain].modes[record.mode]) {
                domains[record.domain].modes[record.mode] = 0;
            }
            domains[record.domain].modes[record.mode]++;
        });

        return domains;
    }
}

module.exports = NanoFileManager;
