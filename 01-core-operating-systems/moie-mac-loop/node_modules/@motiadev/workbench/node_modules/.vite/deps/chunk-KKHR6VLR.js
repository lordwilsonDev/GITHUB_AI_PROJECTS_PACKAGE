// node_modules/@motiadev/stream-client/dist/esm/src/stream-subscription.js
var StreamSubscription = class {
  constructor(sub, state) {
    this.customEventListeners = /* @__PURE__ */ new Map();
    this.closeListeners = /* @__PURE__ */ new Set();
    this.onChangeListeners = /* @__PURE__ */ new Set();
    this.sub = sub;
    this.state = state;
  }
  onEventReceived(event) {
    const customEventListeners = this.customEventListeners.get(event.type);
    if (customEventListeners) {
      const eventData = event.data;
      customEventListeners.forEach((listener) => listener(eventData));
    }
  }
  /**
   * Add a custom event listener. This listener will be called whenever the custom event is received.
   */
  onEvent(type, listener) {
    const listeners = this.customEventListeners.get(type) || [];
    this.customEventListeners.set(type, [...listeners, listener]);
  }
  /**
   * Remove a custom event listener.
   */
  offEvent(type, listener) {
    const listeners = this.customEventListeners.get(type) || [];
    this.customEventListeners.set(type, listeners.filter((l) => l !== listener));
  }
  onClose(listener) {
    this.closeListeners.add(listener);
  }
  close() {
    this.closeListeners.forEach((listener) => listener());
    this.closeListeners.clear();
  }
  /**
   * Add a change listener. This listener will be called whenever the state of the group changes.
   */
  addChangeListener(listener) {
    this.onChangeListeners.add(listener);
  }
  /**
   * Remove a change listener.
   */
  removeChangeListener(listener) {
    this.onChangeListeners.delete(listener);
  }
  /**
   * Get the current state of the group.
   */
  getState() {
    return this.state;
  }
  setState(state) {
    this.state = state;
    this.onChangeListeners.forEach((listener) => listener(state));
  }
};

// node_modules/@motiadev/stream-client/dist/esm/src/stream-group.js
var StreamGroupSubscription = class extends StreamSubscription {
  constructor(sub, sortKey) {
    super(sub, []);
    this.sortKey = sortKey;
    this.lastTimestamp = 0;
    this.lastTimestampMap = /* @__PURE__ */ new Map();
  }
  sort(state) {
    const sortKey = this.sortKey;
    if (sortKey) {
      return state.sort((a, b) => {
        const aValue = a[sortKey];
        const bValue = b[sortKey];
        if (aValue && bValue) {
          return aValue.toString().localeCompare(bValue.toString());
        }
        return 0;
      });
    }
    return state;
  }
  setState(state) {
    super.setState(this.sort(state));
  }
  listener(message) {
    if (message.event.type === "sync") {
      if (message.timestamp < this.lastTimestamp) {
        return;
      }
      this.lastTimestampMap = /* @__PURE__ */ new Map();
      this.lastTimestamp = message.timestamp;
      this.setState(message.event.data);
    } else if (message.event.type === "create") {
      const id = message.event.data.id;
      const state = this.getState();
      if (!state.find((item) => item.id === id)) {
        this.setState([...state, message.event.data]);
      }
    } else if (message.event.type === "update") {
      const messageData = message.event.data;
      const messageDataId = messageData.id;
      const state = this.getState();
      const currentItemTimestamp = this.lastTimestampMap.get(messageDataId);
      if (currentItemTimestamp && currentItemTimestamp >= message.timestamp) {
        return;
      }
      this.lastTimestamp = message.timestamp;
      this.lastTimestampMap.set(messageDataId, message.timestamp);
      this.setState(state.map((item) => item.id === messageDataId ? messageData : item));
    } else if (message.event.type === "delete") {
      const messageDataId = message.event.data.id;
      const state = this.getState();
      this.lastTimestamp = message.timestamp;
      this.lastTimestampMap.set(messageDataId, message.timestamp);
      this.setState(state.filter((item) => item.id !== messageDataId));
    } else if (message.event.type === "event") {
      this.onEventReceived(message.event.event);
    }
  }
};

// node_modules/@motiadev/stream-client/dist/esm/src/stream-item.js
var StreamItemSubscription = class extends StreamSubscription {
  constructor(sub) {
    super(sub, null);
    this.lastEventTimestamp = 0;
  }
  listener(message) {
    if (message.timestamp <= this.lastEventTimestamp) {
      return;
    }
    this.lastEventTimestamp = message.timestamp;
    if (message.event.type === "sync" || message.event.type === "create" || message.event.type === "update") {
      this.setState(message.event.data);
    } else if (message.event.type === "delete") {
      this.setState(null);
    } else if (message.event.type === "event") {
      this.onEventReceived(message.event.event);
    }
  }
};

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/@motiadev/stream-client/dist/esm/src/stream.js
var Stream = class {
  constructor(adapterFactory) {
    this.adapterFactory = adapterFactory;
    this.listeners = {};
    this.ws = this.createSocket();
  }
  createSocket() {
    this.ws = this.adapterFactory();
    this.ws.onMessage((message) => this.messageListener(message));
    this.ws.onOpen(() => this.onSocketOpen());
    this.ws.onClose(() => this.onSocketClose());
    return this.ws;
  }
  /**
   * Subscribe to an item in a stream.
   *
   * @argument streamName - The name of the stream to subscribe to.
   * @argument groupId - The id of the group to subscribe to.
   * @argument id - The id of the item to subscribe to.
   */
  subscribeItem(streamName, groupId, id) {
    const subscriptionId = v4_default();
    const sub = { streamName, groupId, id, subscriptionId };
    const subscription = new StreamItemSubscription(sub);
    this.subscribe(subscription);
    return subscription;
  }
  /**
   * Subscribe to a group in a stream.
   *
   * @argument streamName - The name of the stream to subscribe to.
   * @argument groupId - The id of the group to subscribe to.
   */
  subscribeGroup(streamName, groupId, sortKey) {
    const subscriptionId = v4_default();
    const sub = { streamName, groupId, subscriptionId };
    const subscription = new StreamGroupSubscription(sub, sortKey);
    this.subscribe(subscription);
    return subscription;
  }
  close() {
    this.listeners = {};
    this.ws.close();
  }
  onSocketClose() {
    setTimeout(() => this.createSocket(), 2e3);
  }
  onSocketOpen() {
    Object.values(this.listeners).forEach((listeners) => {
      listeners.forEach((subscription) => this.join(subscription));
    });
  }
  messageListener(event) {
    var _a, _b;
    const message = JSON.parse(event);
    const room = this.roomName(message);
    (_a = this.listeners[room]) == null ? void 0 : _a.forEach((listener) => listener.listener(message));
    if (message.id && message.event.type !== "sync") {
      const groupRoom = this.roomName({
        streamName: message.streamName,
        groupId: message.groupId
      });
      (_b = this.listeners[groupRoom]) == null ? void 0 : _b.forEach((listener) => listener.listener(message));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  subscribe(subscription) {
    const room = this.roomName(subscription.sub);
    if (!this.listeners[room]) {
      this.listeners[room] = /* @__PURE__ */ new Set();
    }
    this.listeners[room].add(subscription);
    this.join(subscription);
    subscription.onClose(() => {
      var _a;
      (_a = this.listeners[room]) == null ? void 0 : _a.delete(subscription);
      this.leave(subscription);
    });
  }
  join(subscription) {
    if (this.ws.isOpen()) {
      this.ws.send(JSON.stringify({ type: "join", data: subscription.sub }));
    }
  }
  leave(subscription) {
    if (this.ws.isOpen()) {
      this.ws.send(JSON.stringify({ type: "leave", data: subscription.sub }));
    }
  }
  roomName(message) {
    return message.id ? `${message.streamName}:group:${message.groupId}:item:${message.id}` : `${message.streamName}:group:${message.groupId}`;
  }
};

// node_modules/@motiadev/stream-client-browser/dist/src/stream-adapter.js
var StreamSocketAdapter = class {
  constructor(address, protocols) {
    this.address = address;
    this.onMessageListeners = [];
    this.onOpenListeners = [];
    this.onCloseListeners = [];
    this.ws = new WebSocket(this.address, protocols);
  }
  connect() {
  }
  send(message) {
    this.ws.send(message);
  }
  onMessage(callback) {
    const listener = (message) => callback(message.data);
    this.ws.addEventListener("message", listener);
    this.onMessageListeners.push(listener);
  }
  onOpen(callback) {
    this.ws.addEventListener("open", callback);
    this.onOpenListeners.push(callback);
  }
  onClose(callback) {
    this.ws.addEventListener("close", callback);
    this.onCloseListeners.push(callback);
  }
  close() {
    this.ws.close();
    this.onMessageListeners.forEach((listener) => this.ws.removeEventListener("message", listener));
    this.onOpenListeners.forEach((listener) => this.ws.removeEventListener("open", listener));
    this.onCloseListeners.forEach((listener) => this.ws.removeEventListener("close", listener));
  }
  isOpen() {
    return this.ws.readyState === WebSocket.OPEN;
  }
};

// node_modules/@motiadev/stream-client-browser/dist/src/stream.js
var Stream2 = class extends Stream {
  constructor(address, options) {
    super(() => new StreamSocketAdapter(address, options == null ? void 0 : options.protocols));
  }
};

export {
  StreamGroupSubscription,
  StreamItemSubscription,
  Stream2 as Stream
};
//# sourceMappingURL=chunk-KKHR6VLR.js.map
